# What is eBPF verifier?
- A static code analyzer
- Statically analyzes the eBPF program before they are executed.
- Properties: 
    - Termination: 
        - Checks if there is no unbounded access in the source code. 
        - The verifier performs a depth-first search approach to traverse the program's control flow to ensure that program does not reaches an infinite loop.
        - Unbounded loops or dynamically computed bounds are not allowed at the source level.
    - Memory safety:
        - Checks out-of-bound memory accesses.
        - Safeguards use-after-free bugs.
        - Unreleased references check
        - Dereferencing a null pointer (a null check needs to be added before the derefencing/referencing a pointer) 
    - Ensuring type safety  
        - Utilizes BPF type format. 
    - Preventing hardware exceptions
        - Example, division by zero
    - Uninitialized register ```r0```

# eBPF Verifier
- After the eBPF program is loaded into the kernel, the verification process ensures that the program is safe.
- Verification involves checking every possible execution path through the program and ensuring that every instruction is safe.
- The verifier also makes some updates to the bytecode to make it ready for execution.
- The verifier works on the bytecode (not the source eBPF code).

## Verification process
- The verifier analyzes the program to assess all possible execution paths.
- It steps through the instructions in order, evaluating them rather than actually executing them.
- The verifier keeps track of the state of each register as it progresses in a structure called **bpf_reg_state**.
    - The structure **bpf_reg_state** has a field called **bpf_reg_type** which indicates the type of value that can be stored in the register.
    - There are several bpf_reg_types:
        - **NOT_INIT** : register has not been set to a value (not initialized register)
        - **SCALAR_VALUE** : register is set to a value that does not represent a pointer
        - **PTR_TO_*** : register holds a pointer to something
            - **PTR_TO_CTX** : register holds a pointer to the context passed as the argument to the eBPF program 
            - **PTR_TO_PACKET** : register holds a pointer to a network packet 
    - The bpf_reg_state also holds a field indicating the range of possible value the register might hold. *It helps in verifying when invalid actions are being attempted.*
    - Everytime the verifier comes to a branch, where a decision has to be made on whether to carry on in sequence or jump to a different instruction, *the verifier pushes a copy of the current state of all registers onto a stack and explores one of the possible paths*. It continues evaluating the instructions until it reaches the return at the end of the program (or reaches the limit on the number of instructions it will process), which is currently one million instructions, at which point it pops a branch off the stack to evaluate next. If it finds an instruction that could result in an invalid operation, it fails verification.
    - **State pruning** : As the verifier works using static analysis in which it explores all possible paths, there might be possibility of state explosion. Hence the verifier utilizes a technique called **State pruning** that avoid reevaluating paths through the program that are essentially equivalent. 

    ## Verifier Log:
    - When the verification of a program fails, the verifier generates a log showing how it reached the conclusion that the program is invalid. 
    - The log of success and failure both can be generated. 
    - The log file generated by the verifier gives lot of information like type of register, range of values that can be stored in the register, which register holds which value and so on. 

    ## Verifier towards completion:
    - The verifier ensures that the eBPF program will run to completion; otherwise, there is a risk that it might consume resources indefinitely. 
    - The verifier has a limit on the total number of instructions that it will process. As of now, the limit is set to 1 million instructions and it is hard coded into the kernel.
    - If the verifier hasn't reched the end of the BPF program before it has processed this many instructions, it rejects the program. 

### References
- [Blogpost1](https://ddosify.com/blog/unveiling-ebpf-verifier-errors/)
