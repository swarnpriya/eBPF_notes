# TODOs

- Support for "sec" attributes in Koka(**Supported**)
- Support for "licence" attributes in Koka(**Solution: Add it like we added the "sec" attributes in Koka and change the compiler accordingly**)
- Support for helper functions in Koka (atleast all the important ones)(**Solution: Add in Koka their equivalent syntax and signature and they map to corresponding eBPF/C helper functions**)
- Write a program transformation that transforms the "C" code generated by Koka compiler to "C" code that would be accepted by the clang compiler tageting BPF
  - Remove the automatic context generated as input argument by the Koka compiler because eBPF program takes only one argument (context related to operations being performed in the eBPF program)
  - Ensure that boxed type is changed to original type as eBPF program can only return "int" and boxed types are mostly structures in generated C code by Koka compiler.
  - ...
- Support all the existing checks performed by the verifier
  - Checking the license(**Solution: Program analysis pass on the source code that traverses the instructions and if helper functions that requires GPL license is used in the program then check
    that GPL licensing is added in the program or not**)
    - Check if the program uses a helper function that is licensed under GPL.
      ```
      SEC("xdp")
      int xdp_hello(struct xdp_md *ctx) {
        void *data = (void *)(long)ctx->data;
        void *data_end = (void *)(long)ctx->data_end;
        bpf_printk("%x %x", data, data_end);
        return XDP_PASS;
      }

      // Removing the license section means the verifier won't let you use
      // GPL-licensed helpers
      char LICENSE[] SEC("license") = "Dual BSD/GPL";
      ```
  - Checking the helper function arguments type(**Solution:Type system can take care for the argument and return types, though adding new types in Koka would be needed**)
    (**For other checks like gpl, pkt_access, argument size... NO CLUE AT THIS MOMENT**)
    - Each helper function has a bpf_func_proto structure: The type system needs to check if helper function satisfies the bpf_func_proto signature or not?
      ```
      struct bpf_func_proto {
      	u64 (*func)(u64 r1, u64 r2, u64 r3, u64 r4, u64 r5);
      	bool gpl_only;
      	bool pkt_access;
      	bool might_sleep;
      	enum bpf_return_type ret_type;
      	union {
      		struct {
      			enum bpf_arg_type arg1_type;
      			enum bpf_arg_type arg2_type;
      			enum bpf_arg_type arg3_type;
      			enum bpf_arg_type arg4_type;
      			enum bpf_arg_type arg5_type;
      		};
      		enum bpf_arg_type arg_type[5];
      	};
      	union {
      		struct {
      			u32 *arg1_btf_id;
      			u32 *arg2_btf_id;
      			u32 *arg3_btf_id;
      			u32 *arg4_btf_id;
      			u32 *arg5_btf_id;
      		};
      		u32 *arg_btf_id[5];
      		struct {
      			size_t arg1_size;
      			size_t arg2_size;
      			size_t arg3_size;
      			size_t arg4_size;
      			size_t arg5_size;
      		};
      		size_t arg_size[5];
      	};
      	int *ret_btf_id; /* return value btf_id */
      	bool (*allowed)(const struct bpf_prog *prog);
      };
      ```
  - Validating helper functions used in a program under their respective "sec" attribute (**Solution: Program analysis pass on the source code that traverses the instructions and check the mapping**)
    - Different helper functions are valid for different BPF program types.
        - For example, the helper function bpf_get_current_pid_tgid() retrieves the current user space process ID and thread ID, but it doesn't make sense to call this from an XDP program
          that is triggered by the receipt of a packet at a network interface, because there is no user space involved.
  - Return type of eBPF program should be int (**Supported**)
  - Check memory accesses are in bound or not
      - BPF programs should only access memory they are suppossed to have access to.
        ```
        SEC("xdp")
        int xdp_hello(struct xdp_md *ctx) {
          void *data = (void *)(long)ctx->data;
          void *data_end = (void *)(long)ctx->data_end;
          // Attempt to read outside the packet
          data_end++;
          bpf_printk("%x %x", data, data_end);
          return XDP_PASS;
        }
  
        char LICENSE[] SEC("license") = "Dual BSD/GPL";
        ```

        ```
        char message[12] = "Hello World";
        // Changing this to <= means and c could have value beyond the bounds of the
        // global message array
        if (c <= sizeof(message)) {
          char a = message[c];
           bpf_printk("%c", a);
        }
        ```
  - Checking Pointers Before Dereferencing
      - All pointers used in the program needs to be checked before they are dereferenced so that there is no program crash due to null pointer dereferencing.
        ```
        // Suppose there is no entry in this map corresponding to uid,
        // this will set p (which is a pointer) to 0
        p = bpf_map_lookup_elem(&my_hash_table, &uid);
        // if(p != 0)
        char a = p -> message[0];
        bpf_printk("%c", a);
        ```
  - Accessing context
      - Depending on the program and attachment type, it may be allowed to access only some of that context information.
  - Loops should terminate
  - Checking the return code (**Supported**)
      - The return code from an eBPF program is stored in Register R0. R0 should not be uninitialized.
        ```
        SEC("xdp")
        int xdp_hello(struct xdp_md *ctx) {
          void *data = (void *)(long)ctx->data;
          void *data_end = (void *)(long)ctx->data_end;
        }

        char LICENSE[] SEC("license") = "Dual BSD/GPL";
        ```
  - Invalid Instructions
    - eBPF programs consist of a set of bytecode instructions.
    - Check should ensure that instructions used in a program are valid bytecode instructions.
    - **We can ignore this check as it would be related to bug in the compiler if it produces invalid bytecode**
          
